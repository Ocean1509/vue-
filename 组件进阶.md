> 我们知道，组件是```Vue```体系的核心，熟练使用组件是掌握```Vue```进行开发的基础。在上一小节中，我们深入了解了```Vue```注册到使用渲染的完整流程，回顾[深入剖析Vue源码 - 组件基础](https://juejin.im/post/5cee4ba4518825092c715438),这一节会在上一节的基础上介绍组件的两个高级用法：异步组件和函数式组件。

### 6.1 异步组件
#### 6.1.1 使用场景
```Vue```作为单页面应用遇到最核心的问题便是首屏加载时间问题，最终打包的脚本文件会包含所有业务和非业务的代码，文件过大也是造成加载速度缓慢的原因。因此作为首屏性能优化的课题，最常用的方法便是文件拆分和代码分离。而按需加载的概念也是在这个前提下引入的。我们往往会把一些非首屏的组件设计成异步组件，按需加载。通俗点理解，异步组件是在需要使用时才去请求加载代码，我们借助webpack可以更加直观。
[图]
webpack遇到异步组件，会将其从主脚本中抽离，减少因为脚本文件过大造成的加载速度缓慢的问题。
#### 6.1.2 工厂函数
```Vue```中允许用户通过以工厂函数的形式定义组件，这个工厂函数会异步解析组件定义，在这个组件需要渲染的时候才会触发该工厂函数，并且会将结果缓存起来，以便其他地方调用。具体使用：
```
// 全局注册：
Vue.component('asyncComponent', function(resolve, reject) {
  require(['./test.vue'], resolve)
})
// 局部注册：
var vm = new Vue({
  el: '#app',
  template: '<div id="app"><asyncComponent></asyncComponent></div>',
  components: {
    asyncComponent: (resolve, reject) => require(['./test.vue'], resolve)
  }
})
```
##### 6.1.2.1 require.ensure
在结合webpack进行异步组件代码分离时，经常需要关注分离文件的```chunkname```,这时可以使用```webpack```提供的```require.ensure```进行代码分离。webpack 在编译时，会静态地解析代码中的 require.ensure()，同时将模块添加到一个分开的 chunk 当中，其中函数的第三个参数为chunk的名字。修改上述的代码写法：
```
Vue.component('asyncComponent', function (resolve, reject) {
   require.ensure([], function () {
     resolve(require('./test.vue'));
   }, 'asyncComponent'); // asyncComponent为chunkname
})
``` 

##### 6.1.2.2 流程分析
有了上一节组件注册的基础，我们来分析异步组件的实现逻辑。简单回忆一下，子组件的创建分为vnode节点的创建和vnode到真实节点生成的过程，而子vnode创建的过程发生在根节点挂载时递归创建子vnode中，遇到子占位符时，会调用createComponent方法。而异步组件也放在这一阶段处理。
```
// 创建子组件过程
  function createComponent (
    Ctor, // 子类构造器
    data,
    context, // vm实例
    children, // 子节点
    tag // 子组件占位符
  ) {
    ···
    // 针对局部注册组件创建子类构造器
    if (isObject(Ctor)) {
      Ctor = baseCtor.extend(Ctor);
    }
    // 异步组件分支
    var asyncFactory;
    if (isUndef(Ctor.cid)) {
      // 异步工厂函数
      asyncFactory = Ctor;
      // 创建异步组件函数
      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
      if (Ctor === undefined) {
        return createAsyncPlaceholder(
          asyncFactory,
          data,
          context,
          children,
          tag
        )
      }
    }
    ···
    // 创建子组件vnode
    var vnode = new VNode(
      ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
      data, undefined, undefined, undefined, context,
      { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
      asyncFactory
    );

    return vnode
  }
```
工厂函数的用法使得```Vue.component(name, options)```的第二个参数不是一个对象，因此不论是全局注册还是局部注册，都不会执行```Vue.extend```将他转变一个构造器，所以```Ctor.cid```不会存在，代码会进入异步组件的分支。
异步组件分支的核心是```resolveAsyncComponent```,接下来只关心工厂函数处理部分。
```
function resolveAsyncComponent (
    factory,
    baseCtor
  ) {
    if (!isDef(factory.owners)) {

      // 异步请求成功处理
      var resolve = function() {}
      // 异步请求失败处理
      var reject = function() {}

      // 创建子组件时会先执行工厂函数，并将resolve和reject传入
      var res = factory(resolve, reject);

      // resolved 同步返回
      return factory.loading
        ? factory.loadingComp
        : factory.resolved
    }
  }
```
工厂函数的处理，总结来说就三点，1. 定义异步请求成功的函数处理，定义异步请求失败的函数处理；2.执行组件定义的工厂函数；3.同步返回请求成功的函数处理。

先关注一下高级函数```once```, 为了防止多个地方同时调用异步组件时，resolve,reject调用多次，```once```函数保证了函数只执行一次。

```
// once函数保证了这个调用函数只在系统中调用一次
function once (fn) {
  // 利用闭包特性将called作为标志位
  var called = false;
  return function () {
    // 调用过则不再调用
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}
```

成功和失败的处理逻辑如下： 
```
// 成功处理
var resolve = once(function (res) {
  // 转成组件构造器，并将其缓存到resolved属性中。
  factory.resolved = ensureCtor(res, baseCtor);
  if (!sync) {
    //强制更新渲染视图
    forceRender(true);
  } else {
    owners.length = 0;
  }
});
// 失败处理
var reject = once(function (reason) {
  warn(
    "Failed to resolve async component: " + (String(factory)) +
    (reason ? ("\nReason: " + reason) : '')
  );
  if (isDef(factory.errorComp)) {
    factory.error = true;
    forceRender(true);
  }
});
```
异步组件加载完毕，会调用resolve定义的方法，方法会通过ensureCtor将加载的结果转换位构造函数，并存储在```resolved```属性中，其中 ```ensureCtor```的定义为：
```
function ensureCtor (comp, base) {
    if (comp.__esModule ||(hasSymbol && comp[Symbol.toStringTag] === 'Module')) {
      comp = comp.default;
    }
    // comp结果为对象时，调用extend方法创建一个子类构造器
    return isObject(comp)
      ? base.extend(comp)
      : comp
  }
```
组件构造器创建完毕，会进行一次视图的重新渲染，由于Vue是数据驱动视图渲染的，而组件在加载到完毕的过程中，并没有数据发生变化，因此需要手动强制更新视图。```forceRender```函数的内部会拿到每个调用异步组件的实例，执行原型上的```$forceUpdate```方法，这部分的知识等到响应式系统时介绍。

异步组件加载失败后，会调用reject定义的方法，方法会提示错误并标记错误，最后同样会强制更新视图。


回到异步组件创建的流程，执行异步过程会为加载中的异步组件创建一个注释节点Vnode
```
  function createComponent (){
    ···
    // 创建异步组件函数
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
    if (Ctor === undefined) {
      // 创建注释节点
      return createAsyncPlaceholder(asyncFactory,data,context,children,tag)
    }
  }
```
```createAsyncPlaceholder```的定义也很简单,其中```createEmptyVNode```之前有介绍过，是创建一个注释节点vnode，而```asyncFactory,asyncMeta```都是用来标注该节点为异步组件的临时节点和相关属性。
```
// 创建注释Vnode
function createAsyncPlaceholder (factory,data,context,children,tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}
```
### 6.2 函数式组件