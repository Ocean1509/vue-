
生命周期图

```
<div id="app"></div>
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.8/dist/vue.js"></script>
var vm = new Vue({
  el: '#app',
  data: {
    message: '选项合并'
  },
  components: {
    'components': {}
  }
})
```
vue工程化都是从创建一个vue实例开始，在创建一个vue实例之后的第一步，系统需要进行init，也就是初始化数据的过程。
```
// Vue 构造函数
function Vue (options) {
  if (!(this instanceof Vue)
  ) {
    // 规定vue只能通过new实例化创建，否则抛出异常
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

// 在引进Vue时，会执行initMixin方法，这个方法只单纯在vue的原型上定义一个init的方法，而init方法只在在实例化Vue时执行
initMixin(Vue);

// 其他初始化过程。。。
···

```
在这一章节中，我们将围绕vue数据的初始化展开解析。

#### 1.1 Vue构造函数的默认选项
```
var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];
Vue.options = Object.create(null);
ASSET_TYPES.forEach(function (type) {
  Vue.options[type + 's'] = Object.create(null);
});
Vue.options._base = Vue;
```
Vue构造函数自身有四个默认配置选项，分别是component，directive， filter以及返回自身构造器的_base(这里先不展开对每个属性内容的介绍)。这四个属性挂载在构造函数的options属性上。


我们抓取_init方法合并选项的核心部分代码如下:
```
function initMixin (Vue) {
    Vue.prototype._init = function (options) {
      var vm = this;
      // a uid
      // 记录实例化多少个vue对象
      vm._uid = uid$3++;

      // 选项合并，将合并后的选项赋值给实例的$options属性
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor), // 返回Vue构造函数自身的配置项
        options || {},
        vm
      );
    };
  }
```
其中每个vue实例对象都有一个$options属性，这个属性会将new Vue(options)用户传递的options和Vue构造函数自身的options进行合并。


#### 1.2 选项校验
选项合并的核心代码如下，我们分别来阐述这一过程。下面只会针对components和props的校验讲解，其他的如inject, directive校验类似，请自行对着源码解析。
```
 function mergeOptions ( parent, child, vm ) {
    {
      checkComponents(child); // 对选项components进行规范检测
    }

    if (typeof child === 'function') {
      child = child.options;
    }

    normalizeProps(child, vm); // 校验props选项
    normalizeInject(child, vm); // 校验inject选项
    normalizeDirectives(child); // 校验directive选项

    if (!child._base) {
      if (child.extends) {
        parent = mergeOptions(parent, child.extends, vm);
      }
      if (child.mixins) {
        for (var i = 0, l = child.mixins.length; i < l; i++) {
          parent = mergeOptions(parent, child.mixins[i], vm);
        }
      }
    }

    var options = {};
    var key;
    for (key in parent) {
      mergeField(key);
    }
    for (key in child) {
      if (!hasOwn(parent, key)) {
        mergeField(key);
      }
    }
    function mergeField (key) {
      var strat = strats[key] || defaultStrat;
      options[key] = strat(parent[key], child[key], vm, key);
    }
    return options
  }
```
##### 1.2.1 components规范检验
选项合并过程我们更多的不可控在于不知道用户传了哪些配置选项，这些配置是否符合规范，例如我们可以在vue实例化时传入组件选项以此来注册组件，然后，组件命名需要遵守很多规范，比如不能用html保留的标签(如：img,p),且只能以字母开头等。因此在选项合并之前，需要对规范进行检查。
```
// components规范检查函数
function checkComponents (options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}
function validateComponentName (name) {
  if (!new RegExp(("^[a-zA-Z][\\-\\.0-9_" + (unicodeRegExp.source) + "]*$")).test(name)) {
    // 正则判断检测是否为非法的标签
    warn(
      'Invalid component name: "' + name + '". Component names ' +
      'should conform to valid custom element name in html5 specification.'
    );
  }
  // 不能使用Vue自身自定义的组件名，如slot, component,不能使用html的保留标签，如 h1, svg等
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn(
      'Do not use built-in or reserved HTML elements as component ' +
      'id: ' + name
    );
  }
}
```
##### 1.2.2 props规范检验
从vue的使用文档看，props选项的形式有两种，一种是['a', 'b', 'c']的数组形式,一种是{ a: { type: 'String', default: 'hahah' }}带有校验规则的形式。从源码上看，两种形式最终都会转换成对象的形式。
```
// props规范校验
  function normalizeProps (options, vm) {
    var props = options.props;
    if (!props) { return }
    var res = {};
    var i, val, name;
    // props选项数据有两种形式，一种是['a', 'b', 'c'],一种是{ a: { type: 'String', default: 'hahah' }}
    if (Array.isArray(props)) {
      i = props.length;
      while (i--) {
        val = props[i];
        if (typeof val === 'string') {
          name = camelize(val);
          res[name] = { type: null }; // 默认将数组形式的props转换为对象形式。
        } else {
          // 保证是字符串
          warn('props must be strings when using array syntax.');
        }
      }
    } else if (isPlainObject(props)) {
      for (var key in props) {
        val = props[key];
        name = camelize(key);
        res[name] = isPlainObject(val)
          ? val
          : { type: val };
      }
    } else {
      // 非数组，非对象则判定props选项传递非法
      warn(
        "Invalid value for option \"props\": expected an Array or an Object, " +
        "but got " + (toRawType(props)) + ".",
        vm
      );
    }
    options.props = res;
  }
```


##### 1.2.3 函数缓存
在读到props规范检验时，我发现了一段函数优化的代码，他将每次执行函数后的值缓存起来，下次重复执行的时候调用缓存的数据，以此提高前端性能，这是典型的偏函数的实际应用，可以参考我另一篇文章[打造属于自己的underscore系列（五）-  偏函数和函数柯里化](https://juejin.im/post/5c619de8f265da2d8a559131)
```
function cached (fn) {
  var cache = Object.create(null); // 创建空对象作为缓存对象
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str)) // 每次执行时缓存对象有值则不需要执行函数方法，没有则执行并缓存起来
  })
}

var camelize = cached(function (str) {
  // 将诸如 'a-b'的写法统一处理成驼峰写法'aB'
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

```


#### 1.3 子类构造器
在开始讲选项合并策略时，需要先了解一个东西，子类构造器，在vue的应用实例中，我们通过```Vue.extend({ template: '<div></div>', data: function() {} })```创建一个子类，这个子类和Vue实例创建的父类一样，可以通过创建实例并挂载到具体的一个元素上。具体实现如下所示,只简单抽取部分代码：
```
Vue.extend = function (extendOptions) {
  extendOptions = extendOptions || {};
  var Super = this;

  var name = extendOptions.name || Super.options.name;
  if (name) {
    validateComponentName(name); // 校验子类的名称是否符合规范
  }

  var Sub = function VueComponent (options) { // 子类构造器
    this._init(options);
  };
  Sub.prototype = Object.create(Super.prototype); // 子类继承于父类
  Sub.prototype.constructor = Sub;
  Sub.cid = cid++;
  // 子类和父类构造器的配置选项进行合并
  Sub.options = mergeOptions(
    Super.options,
    extendOptions
  );

  return Sub // 返回子类构造函数
};
```

#### 1.4 合并策略
引入子类构造器的概念，目的是为了说明在合并选项时，不单纯需要考虑vue实例传递的用户配置和Vue自身的配置合并，当存在子类构造器时还需要考虑子类和父类之间选项的合并，了解这点，接下来在分析合并策略时可以掌握得更加深刻。
合并策略之所以是难点，其中一个是合并选项类型繁多，大体可以分为以下三类Vue自定义策略， 父类自身配置， 子类自身策略(用户配置)。如何理解呢？
- Vue自定义策略，vue在选项合并的时候对一些特殊的选项有自身定义好的合并策略，例如data的合并，el的合并，而每一个的合并规则都不一样，因此需要对每一个规定选项进行特殊的合并处理
- 父类自身配置，首先创建一个vue实例时，Vue构造函数自身的options属于父类自身配置，我们需要将实例传递的配置和Vue.options进行合并。再者前面提到的```var P = Vue.extends(); var C = P.extends()```，P作为C的父类，在合并选项时同样需要考虑进去。
- 子类自身策略(用户配置)，用户自身选项也就是通过new 实例传递的options选项

在Vue源码中，如何处理好这三个选项的合并，思路是这样的：
1. 首选默认自定义策略，根据不同选项的策略合并子和父的配置项
2. 不存在自定义策略时，有子类配置选项则默认使用子类配置选项，没有则选择父类配置选项。
```
function mergeOptions ( parent, child, vm ) {
  ···
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat; // 如果有自定义选项策略，则使用自定义选项策略，否则选择子类配置选项
    options[key] = strat(parent[key], child[key], vm, key);
  }

  return options
}
```

#### 1.5 默认策略
Vue自定义选项策略有很多，我们先列举其中的几个进行剖析。

##### 1.5.1 el合并
我们只在创建vue的实例时才会执行节点挂载，在子类或者子组件中无法定义el选项，代码实现如下
```
strats.el = function (parent, child, vm, key) {
  if (!vm) {  // 是否是vm实例
    warn(
      "option \"" + key + "\" can only be used during instance " +
      'creation with the `new` keyword.'
    );
  }
  return defaultStrat(parent, child)
};
```
##### 1.5.2 data合并
另一个合并的重点是data的合并策略，data在vue创建实例时传递的是一个对象，而在组件内部定义时只能传递一个函数，
```
strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (!vm) {// 判断是否为Vue创建的实例，否则为子父类的关系
      if (childVal && typeof childVal !== 'function') { // 必须保证子类的data类型是一个函数而不是一个对象
        warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.',vm);
        return parentVal
      }
      return mergeDataOrFn(parentVal, childVal)
    }
  return mergeDataOrFn(parentVal, childVal, vm); // vue实例时需要传递vm作为函数的第三个参数
};
```
做了data选项的检验后，重点关注mergeDataOrFn函数的内部逻辑，代码中依然通过vm来区分是否为子类构造器的data合并。

```
function mergeDataOrFn ( parentVal, childVal, vm ) {
  if (!vm) {
    if (!childVal) { // 子类不存在data选项，则合并结果为父类data选项
      return parentVal
    }
    if (!parentVal) { // 父类不存在data选项，则合并结果为子类data选项
      return childVal
    }
    return function mergedDataFn () {
      // 子类实例和父类实例，分别将子类和父类实例中data函数执行后返回的对象传递给mergeData函数做数据合并
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
    // vue构造函数实例对象
    return function mergedInstanceDataFn () {
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm, vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm, vm)
        : parentVal;
      if (instanceData) {
        // 当实例中传递data选项时，将实例的data对象和Vm构造函数上的data属性选项合并
        return mergeData(instanceData, defaultData)
      } else {
        // 当实例中不传递data时，默认返回Vm构造函数上的data属性选项
        return defaultData
      }
    }
  }
}
```
如何实现数据合并
```
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;

  var keys = hasSymbol
    ? Reflect.ownKeys(from)
    : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    if (key === '__ob__') { continue }
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (
      toVal !== fromVal &&
      isPlainObject(toVal) &&
      isPlainObject(fromVal)
    ) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}
```



