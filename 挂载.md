>前面的几篇文章我们从new Vue初始化开始，分别介绍了选项的配置合并,设置vue实例代理以及初始化生命周期的操作，按照vue源码设计的思路，接下来还会进行初始化事件中心，初始化渲染,初始化数据并建立响应式系统的操作。在一系列的初始化操作后，vue会将模板和数据渲染成为最终的DOM。然而在初始化数据和建立响应式系统的过程中，我们需要弄清楚数据是如何驱动模板乃至视图更新。因此弄清楚这一点，我们把vue挂载，渲染模板数据到视图的过程放在前面分析。

### 3.1 Runtime Only VS Runtime + Compiler
在正文开始之前，先了解vue基于源码构建的两个版本，一个是runtime only版本，另一个是runtime加compiler的版本，两个版本的主要区别在于后者的源码包括了一个编译器。
什么是编译器，百度百科上面的解释是

>简单讲，编译器就是将“一种语言（通常为高级语言）”翻译为“另一种语言（通常为低级语言）”的程序。一个现代编译器的主要工作流程：源代码 (source code) → 预处理器 (preprocessor) → 编译器 (compiler) → 目标代码 (object code) → 链接器 (Linker) → 可执行程序 (executables)。

简单的理解，编译器是一个提供了将源代码转化为目标代码的工具。更进一步理解，vue内置的编译器实现了将.vue文件转换编译为可执行javascript脚本的功能。

##### 3.1.1 Runtime + Compiler
一个完整的vue版本是包含编译器的，我们可以使用template属性进行模板编写。编译器会自动将模板编译成render函数。
```
// 需要编译器的版本
new Vue({
  template: '<div>{{ hi }}</div>'
})
```
##### 3.1.2 Runtime Only
而对于一个不包含编译器的runtime-only版本，需要传递一个编译好的模板，如下所示：
```
// 不需要编译器
new Vue({
  render (h) {
    return h('div', this.hi)
  }
})
```
很明显，编译过程对性能有一定的损耗，并且由于加入了编译过程的代码，vue代码体积也更加庞大，所以我们可以借助webpack的vue-loader工具进行编译，将编译阶段从vue的构建中剥离出来，这样既优化的性能，也缩小了体积。

### 3.2 挂载的基本思路


