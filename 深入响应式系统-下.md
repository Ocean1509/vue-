initState过程
  
  初始化data


    将data对象设置观察者属性，Observer 只要设置成拥有观察属性，则对象下的所有属性都会重写getter和setter方法，而getter，setting方法会进行依赖的收集和派发更新
  
    一个实例一个Observer，Observer会对每个属性值的getter和setter进行重写。

    其中会对数组和对象做不同的处理


    Observer -> defineReavtive(设置getter， setter) -> 遇到对象则递归调用Observer
    所以Observer的作用是将data对象中的每个属性都设置成响应式对象





  
  props为什么是单向数据流 ?
      举个例子，父组件维护了一个状态，假设子组件可随意更改父组件甚至祖宗组件的状态，那各组件的状态改变就会变得难以追溯，父组件的状态也可能被子组件意外修改而不可察觉。而单向数据流保证了父组件的状态不会被子组件意外修改如果要修改，只能通过在子组件中dispatch一个action来对全局状态修改，全局状态在通过props分发给子组件；又或是调用父组件的方法；又或是发事件，这些操作是肉眼可见且可控的（用函数式来说，保证了组件就是无副作用的纯函数），不至于造成状态总被意外修改而导致难以维护的情况。







  
  
  初始化initComputed
    computed可以是对象，也可以是函数，但是对象必须有getter方法

    创建内部watcher

  
  初始化 initWatch
    watch 的属性可以是对象，也可以是数组，数组会遍历createWatcher
    createWatcher最终调用 vm.$watch
  







watcher 
  渲染watcher 会在根实例上添加_watcher 属性，

  watcher 和 watchers
同一时刻只能渲染一个watcher


$mount -> 生成渲染wather -> render函数触发 getter方法

```
if (Dep.target) {
  dep.depend();
  if (childOb) {
    childOb.dep.depend();
    if (Array.isArray(value)) {
      dependArray(value);
    }
  }
}
```

第一个Dep.target 为渲染 watcher
dep.depend执行的是watcher 的depend方法

watcher可以理解为被观察者


Dep 是用来存watcher (渲染watcher,和用户watcher)

Dep.target是全局唯一的watcher，在同一时间只有一个唯一的watcher被计算，所以需要不断的维护Dep的静态属性。



1. 什么时候有new Dep,一个数据一个depth？
2. Dep的subs属性收集了什么类型的依赖
3. 每个watcher怎么知道被哪些Dep收集
4. watcher的分类有哪些，分别是什么区别
5. 手写的watch监听数据变化以及页面数据渲染在数据发生变化时，优先级怎么排



data: 
依赖收集
  1.初始化data时，将data变成响应式数据，并且为每个数据实例化一个Dep
  2.组件渲染时会实例化一个渲染watcher，此时当前的watcher为渲染watcher，并且会返回到对象上的属性，此时触发getter方法
  3.触发getter方法会做四件事
   3.1 为当前的渲染watcher添加拥有的数据依赖Dep
   3.2 为数据依赖添加需要监听的watcher，即把当前的 watcher 订阅到这个数据持有的 dep 的 subs 中
   3.3 当属性的值是对象是，会递归执行observe，将属性也转换过一个响应对象
   3.4 遇到数组
  4.添加依赖Dep时会做逻辑判断，避免同一数据添加多次
派发更新
  1. 数据相等时，getter不存在时不做任何操作
  2. 新值为对象时，会对该值的属性进行递归的依赖收集。
  3. 通知数据Dep收集的watcher数据进行更新。
  4. 遍历收集的每个watcher，执行update更新状态操作。
  5. 更新时会将每个watcher推到队列中，等下一个tick时一次执行每个watcher的run操作。
  6. run操作执行get方法，也就是重新计算，并且会再次收集依赖。针对渲染watcher而言，会重新执行updateComponent的视图更新。
  7. 在重新计算getter后，会进行依赖的清除，什么情况会有依赖的清除呢。我们经常会用 v-if 来进行模板的切换，v-if会执行不同的模板渲染，也因此会执行不同的数据渲染。例如A模板会监听a数据，B模板会监听b数据，当渲染B模板时，如果不进行旧依赖的清除，在B模板的场景，a数据的变化同样会引起依赖的重新渲染更新，这会造成性能的浪费。因此在每次重新计算getter后，会进行依赖的清除，新的渲染模板监听的watcher和旧的进行对比。



队列遍历
  1.组件的更新由父到子；因为父组件的创建过程是先于子的，所以 watcher 的创建也是先父后子，执行顺序也应该保持先父后子。

  2.用户的自定义 watcher 要优先于渲染 watcher 执行；因为用户自定义 watcher 是在渲染 watcher 之前创建的。

  3.如果一个组件在父组件的 watcher 执行期间被销毁，那么它对应的 watcher 执行都可以被跳过，所以父组件的 watcher 应该先执行。




computed
  依赖收集
    1. computed初始化阶段，遍历computed的每一个属性，为每个属性创建一个computed watcher
    2. 页面模板渲染过程访问到computed属性，触发computed属性的getter进行依赖收集
    2. 依赖收集之前，会先进行回调函数的计算。在计算阶段，如果访问data对象的其他属性值，会触发data数据getter方法进行依赖收集，此时data属性的Dep收集器将computed watcher作为依赖进行收集
    3.getter执行完毕，在清除依赖的过程会将访问到的数据自身持有的 dep 添加到当前正在计算的 watcher 中。并且每个data属性也会收集一个渲染watcher
    4.为渲染watcher订阅computed watcher的变化

  派发更新
    1. 计算数据依赖的数据发生更新,通过数据依赖收集器dep的notify方法，对每个收集的依赖进行状态更新。
    2. 遇到computed watcher不会立刻执行依赖派发更新，而是通过dirty进行标记
    3. 由于数据拥有渲染watcher这个依赖，所以会执行updateComponent进行视图重新渲染。render过程中访问到计算属性又会对计算属性重新求值，保证改变前后两个值不同时才会更新下视图



watch
  依赖收集
  1. watch数据初始化时会执行createWacher，createWatcher会调用原型上的$watch方法,即手动创建一个user watcher,
  2. user watcher 在创建完毕后会执行一次getter求值，



computed watcher 在实例化watcher时并不会立刻求值，
```
// lazy为计算属性标志，当watcher为计算watcher时，不会理解执行get方法进行求值
    this.value = this.lazy
      ? undefined
      : this.get();
```