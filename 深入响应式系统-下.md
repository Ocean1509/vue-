initState过程
  
  初始化data


    将data对象设置观察者属性，Observer 只要设置成拥有观察属性，则对象下的所有属性都会重写getter和setter方法，而getter，setting方法会进行依赖的收集和派发更新
  
    一个实例一个Observer，Observer会对每个属性值的getter和setter进行重写。

    其中会对数组和对象做不同的处理


    Observer -> defineReavtive(设置getter， setter) -> 遇到对象则递归调用Observer
    所以Observer的作用是将data对象中的每个属性都设置成响应式对象





  
  props为什么是单向数据流 ?
      举个例子，父组件维护了一个状态，假设子组件可随意更改父组件甚至祖宗组件的状态，那各组件的状态改变就会变得难以追溯，父组件的状态也可能被子组件意外修改而不可察觉。而单向数据流保证了父组件的状态不会被子组件意外修改如果要修改，只能通过在子组件中dispatch一个action来对全局状态修改，全局状态在通过props分发给子组件；又或是调用父组件的方法；又或是发事件，这些操作是肉眼可见且可控的（用函数式来说，保证了组件就是无副作用的纯函数），不至于造成状态总被意外修改而导致难以维护的情况。







  
  
  初始化initComputed
    computed可以是对象，也可以是函数，但是对象必须有getter方法

    创建内部watcher

  
  初始化 initWatch
    watch 的属性可以是对象，也可以是数组，数组会遍历createWatcher
    createWatcher最终调用 vm.$watch
  







watcher 
  渲染watcher 会在根实例上添加_watcher 属性，

  watcher 和 watchers
同一时刻只能渲染一个watcher


$mount -> 生成渲染wather -> render函数触发 getter方法

```
if (Dep.target) {
  dep.depend();
  if (childOb) {
    childOb.dep.depend();
    if (Array.isArray(value)) {
      dependArray(value);
    }
  }
}
```

第一个Dep.target 为渲染 watcher
dep.depend执行的是watcher 的depend方法

watcher可以理解为被观察者


Dep 是用来存watcher (渲染watcher,和用户watcher)