> 组件是Vue的一个重要核心，我们在进行项目工程化时，会将页面的结构组件化，组件化意味着独立和共享。编写Vue组件是掌握Vue开发的核心基础，Vue的官网也花了大篇幅介绍了组件的知识，并且也深入详解了Vue的使用。这一节内容中，我们将深入Vue组件部分的源码，剖析Vue组件化的设计，了解内部工作原理，这让我们在处理Vue组件相关的问题上更加得心应手

### 5.1 组件两种注册方式
熟悉Vue的开发流程的都知道，Vue组件在使用之前需要进行注册，而注册的方式有两种，全局注册和局部注册。在进入源码分析之前，我们先回忆一下两者的用法，这也方便后续掌握两者的差异。

##### 5.1.1 全局注册
```
Vue.component('my-test', {
    template: '<div>{{test}}</div>',
    data () {
        return {
            test: 1212
        }
    }
})
var vm = new Vue({
    el: '#app',
    template: '<div id="app"><my-test><my-test/></div>'
})
```
其中组件的全局注册需要在全局实例化Vue前调用,且它们在注册之后可以用在任何新创建的 Vue 根实例的模板中
##### 5.1.2 局部注册
```
var myTest = {
    template: '<div>{{test}}</div>',
    data () {
        return {
            test: 1212
        }
    }
}
var vm = new Vue({
    el: '#app',
    component: {
        myTest
    }
})
```
当只需要在某个局部用到某个组件时，可以使用局部注册的方式进行组件注册，此时局部注册的组件只能在注册该组件的组件内部使用。

##### 5.1.3 注册过程
简单回顾两种组件注册方式后，我们来看所谓注册过程到底发生了什么，我们以全局组件注册为例,它通过```Vue.component(name, {...})```进行组件注册，```Vue.component```的定义在源码初始化中
```
// 初始化全局api
initAssetRegisters(Vue);
var ASSET_TYPES = [
    'component',
    'directive',
    'filter'
];
function initAssetRegisters(Vue){
    // 定义ASSET_TYPES中每个属性的方法，其中包括component
    ASSET_TYPES.forEach(function (type) {
    // type: component,directive,filter
      Vue[type] = function (id,definition) {
          ...
          if (type === 'component') {
            // 验证component组件名字是否合法
            validateComponentName(id);
          }
          if (type === 'component' && isPlainObject(definition)) {
            // 组件名称设置
            definition.name = definition.name || id;
            // Vue.extend() 创建子组件，返回子类构造器
            definition = this.options._base.extend(definition);
          }
          // 为Vue.options 上的component属性添加将子类构造器
          this.options[type + 's'][id] = definition;
          return definition
        }
    });
}
```
源码中全局注册的实际是调用构造函数Vue的静态方法extend,并且为Vue.options 上的component属性添加将子类构造器。其中extend方法的定义我们在[深入剖析Vue源码 - 选项合并(上)](https://juejin.im/post/5c8f40af6fb9a070f90aaf8f)中的子类构造器一段中有介绍这里不赘述，总结而言```Vue.extend```创建了一个基于父Vue的子类，创建过程会继承父类的方法，并对父类子类的配置进行合并，最终返回一个子类的构造器。
而这里留下一个问题，局部注册和全局注册的在实现上的区别在哪里？
### 5.2 











// 全局注册组件
// 函数式组件  组件变为无状态、无实例的函数化组件。因为只是函数，所以渲染的开销相对来说，较小



需要通过编程实现在多种组件中选择一种。
children、props 或者 data 在传递给子组件之前，处理它们
[合法的命名规则](https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name)


Vue.component(),第二个参数不传递时，会获取到注册的组件(构造器)

组件名称： 如果组件的选项有name，则用name作为组件名称，或者用Vue.component 的第一个参数作为组件名称

validateComponentName 函数用来校验组件名称，这个函数在Vue源码的几个不同场景都调用了，很明显不管在开发还是生产阶段，Vue都严格把控着组件的命名规范，尤其在开发阶段会将这类报错提前告知开发者，提高效率。

```
// Vue.options里的_base属性存储Vue构造器
Vue.options._base = Vue;

```


1. 组件注册   vm.$options.component - 子类构造器
2. mount 挂载  执行父组件挂载流程
3. render函数生成vnode过程中，子会优先父执行生成vnode过程。遇到子组件占位符，判断是否为普通标签，不是则以组件占位符处理，创建子组件（期间，判断组件是否已经注册），创建子组件时执行createComponent过程
4. createComponent的过程也是递归调用创建子组件的过程，最终也是生成vnode的过程

构造子类构造函数 - 安装组件钩子函数 - 实例化 vnode

5. 生成vue-component  vnode过程
6. 所有的chilren  vnode过程完成后，完成跟节点vnode生成过程



 组件内部自带钩子
 componentVNodeHooks

 patch 核心 createElm 构建真实DOM节点
 -> chilren数组 vnode执行 createChildren方法
 -> createChilren方法内部执行createElm创建真实节点
 -> 循环递归，会将所有子组件真实节点创建完毕在创建最外层根节点


 其实判断是否为组件的条件是， 组件有钩子函数，
 创建真实节点的过程，会调用一次init钩子函数
 init钩子函数会进行子组件的实例化，并挂载组件到父元素上
 