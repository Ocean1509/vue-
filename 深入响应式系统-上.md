initState过程
  初始化props

    props的流程
      - 父组件遇到子组件的占位符节点时，会解析属性，props 的使用是通过属性的形式，如： ，在AST 生成render函数阶段，会解析成 { attrs: {属性： '***'}} 的形式
      - 而在子组件中，props在组件初始化时会进行选项合并，最终配置项里带有props的对象配置
        如： props: { num: { type: null }}
      - 解析出的属性对象会引data的形式传递给组件创建函数 createComponent函数
      - createComponent函数会先对props 进行一次校验和写法规范，之后以组件配置componentOptions的形式， {propsData: '***' } 创建组件Vnode
        ```
        // 创建子组件vnode
          var vnode = new VNode(
            ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
            data, undefined, undefined, undefined, context,
            { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
            asyncFactory
          );
        ```
      - extractPropsFromVNodeData 
         注意点： data.attrs针对编译生成的render函数，data.props针对用户自定义的render函数

         tips: HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命
      - 这个初始化props的过程是在父组件遇到子组件占位符节点时发生的。
    
    接下来子组件进入  initProps的流程

    定义响应式对象

  

  初始化methods  - 简单描述

  初始化data
    组件的data在初始化选项合并时会将data转换成一个函数
    数据对象会挂载到 vm._data 上
    并且会做一层代理，当直接访问 vm.** 时，会代理访问vm._data的值

    将data对象设置观察者属性，Observer 只要设置成拥有观察属性，则对象下的所有属性都会重写getter和setter方法，而getter，setting方法会进行依赖的收集和派发更新
  
    一个实例一个Observer，Observer会对每个属性值的getter和setter进行重写。

    其中会对数组和对象做不同的处理


    Observer -> defineReavtive(设置getter， setter) -> 遇到对象则递归调用Observer
    所以Observer的作用是将data对象中的每个属性都设置成响应式对象

  
  
  初始化initComputed
    computed可以是对象，也可以是函数，但是对象必须有getter方法

    创建内部watcher

  
  初始化 initWatch
    watch 的属性可以是对象，也可以是数组，数组会遍历createWatcher
    createWatcher最终调用 vm.$watch
  


  
  props为什么是单向数据流 ?
      举个例子，父组件维护了一个状态，假设子组件可随意更改父组件甚至祖宗组件的状态，那各组件的状态改变就会变得难以追溯，父组件的状态也可能被子组件意外修改而不可察觉。而单向数据流保证了父组件的状态不会被子组件意外修改如果要修改，只能通过在子组件中dispatch一个action来对全局状态修改，全局状态在通过props分发给子组件；又或是调用父组件的方法；又或是发事件，这些操作是肉眼可见且可控的（用函数式来说，保证了组件就是无副作用的纯函数），不至于造成状态总被意外修改而导致难以维护的情况。




watcher 
  渲染watcher 会在根实例上添加_watcher 属性，

  watcher 和 watchers
同一时刻只能渲染一个watcher


$mount -> 生成渲染wather -> render函数触发 getter方法

```
if (Dep.target) {
  dep.depend();
  if (childOb) {
    childOb.dep.depend();
    if (Array.isArray(value)) {
      dependArray(value);
    }
  }
}
```

第一个Dep.target 为渲染 watcher
dep.depend执行的是watcher 的depend方法

watcher可以理解为被观察者


Dep 是用来存watcher (渲染watcher,和用户watcher)


### 7.4 极简风的响应式系统
Vue的响应式系统构建是比较复杂的，直接进入源码分析构建的每一个流程会让理解变得困难，因此我觉得在尽可能保留源码的设计逻辑下有必要用最小的代码构建一个最基础的响应式系统。```Dep,Watcher,Observer```概念也有助于下一篇对响应式系统设计细节的分析。

##### 7.4.1 框架搭建
我们以```MyVue```作为类响应式框架，框架的搭建不做赘述，我们模拟```Vue```源码的实现思路，实例化```MyVue```时会传递一个选项配置，精简的代码只有一个```id```挂载元素和一个即将构建的响应式对象```data```,实例化时会先进行数据的初始化，这一步就是响应式的构建，我们稍后分析。数据初始化后开始进行真实```DOM```的挂载。
```
var vm = new MyVue({
  id: '#app',
  data: {
    test: 12
  }
})
// myVue.js
(function(global) {
  class MyVue {
      constructor(options) {
        this.options = options;
        // 数据的初始化
        this.initData(options);
        let el = this.options.id;
        // 实例的挂载
        this.$mount(el);
      }
      initData(options) {
      }
      $mount(el) {
      }
    }
}(window))
```
##### 7.4.2 设置响应式对象 - Observer
要将数据变成响应式对象，需要利用```Object.defineProperty```对数据的```getter,setter```方法进行改写，如果对```Object.defineProperty```不了解，可以先回头看系列的第三篇[深入剖析Vue源码 - 数据代理，关联子父组件](https://juejin.im/post/5ca44c6151882543fb5ac95f)。在数据读取```getter```阶段我们会进行**依赖的收集**，在数据的修改```setter```阶段，我们会进行**依赖的更新**(这两个概念的介绍放在后面)。因此在数据初始化阶段，我们会利用```Observer```这个类将数据对象修改为相应式对象，而这是所有流程的基础。
```
class MyVue {
  initData(options) {
    if(!options.data) return;
    this.data = options.data;
    // 将数据重置getter，setter方法
    new Observer(options.data);
  }
}
// Observer类的定义
class Observer {
  constructor(data) {
    // 实例化时执行walk方法对每个数据属性重写getter，setter方法
    this.walk(data)
  }

  walk(obj) {
    const keys = Object.keys(obj);
    for(let i = 0;i< keys.length; i++) {
      // Object.defineProperty的处理逻辑
      defineReactive(obj, keys[i])
    }
  }
}
```
##### 7.4.3 依赖本身 - Watcher
我们可以这样理解，一个Watcher实例就是一个依赖，数据不管是在渲染模板时使用还是在用户计算时使用，都可以算做一个需要监听的依赖，watcher中记录着这个依赖监听的状态，其中最重要的是如何更新状态的方法。
```
// 监听的依赖
class Watcher {
  constructor(expOrFn, isRenderWatcher) {
    this.getter = expOrFn;
    // Watcher.prototype.get的调用会进行状态的更新。
    this.get();
  }

  get() {}
}
```
哪个时间点会实例化```watcher```并更新数据状态呢？显然在渲染数据到真实```DOM```时可以创建```watcher```。```$mount```流程前面章节介绍过，会经历模板生成```render```函数和```render```函数渲染真实```DOM```的过程。我取巧的对代码做了精简，```updateView```浓缩了这一过程。
```
class MyVue {
  $mount(el) {
    // 直接改写innerHTML
    const updateView = _ => {
      let innerHtml = document.querySelector(el).innerHTML;
      let key = innerHtml.match(/{{(\w+)}}/)[1];
      document.querySelector(el).innerHTML = this.options.data[key]
    }
    // 创建一个渲染的依赖。
    new Watcher(updateView, true)
  }
}
```
##### 7.4.4 依赖管理 - Dep
```watcher```如果理解为每个数据需要监听的依赖，那么```Dep``` 可以理解为对依赖的一种管理。数据可以在渲染中使用，也可以在计算属性中使用。相应的每个数据对应的```watcher```也有很多。而我们在更新数据时，如何通知到数据相关的每一个依赖，这就需要```Dep```进行通知管理了。并且浏览器同一时间只能更新一个```watcher```,所以也需要一个属性去记录当前更新的```watcher```。而```Dep```这个类只需要做两件事情，将依赖进行收集，派发依赖进行更新。
```
let uid = 0;
class Dep {
  constructor() {
    this.id = uid++;
    this.subs = []
  }
  // 依赖收集
  depend() {
    if(Dep.target) {
      // Dep.target是当前的watcher,将当前的依赖推到subs中
      this.subs.push(Dep.target)
    }
  }
  // 派发更新
  notify() {
    const subs = this.subs.slice();
    for (var i = 0, l = subs.length; i < l; i++) { 
      // 遍历dep中的依赖，对每个依赖执行更新操作
      subs[i].update();
    }
  }
}

Dep.target = null;
```

##### 7.4.5 依赖管理过程 - defineReactive
前面的```Observer```实例化最终会调用```defineReactive```重写```getter,setter```方法。这个方法初始会实例化一个```Dep```,也就是创建一个数据的依赖管理。在重写的```getter```方法中会进行依赖的收集，也就是调用```dep.depend```的方法。在```setter```阶段，比较两个数不同后，会调用依赖的派发更新。即```dep.notify```
```
const defineReactive = (obj, key) => {
  const dep = new Dep();
  const property = Object.getOwnPropertyDescriptor(obj);
  let val = obj[key]
  if(property && property.configurable === false) return;
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: true,
    get() {
      // 做依赖的收集
      if(Dep.target) {
        dep.depend()
      }
      return val
    },
    set(nval) {
      if(nval === val) return
      // 派发更新
      val = nval
      dep.notify();
    }
  })
}
```
回过头来看```watcher```,实例化```watcher```时会将```Dep.target```设置为当前的```watcher```,执行完状态更新函数之后，再将```Dep.target```置空。这样在收集依赖时只要将```Dep.target```当前的```watcher push```到```Dep```的```subs```数组即可。而在派发更新阶段也只需要重新更新状态即可。

```
class Watcher {
  constructor(expOrFn, isRenderWatcher) {
    this.getter = expOrFn;
    // Watcher.prototype.get的调用会进行状态的更新。
    this.get();
  }

  get() {
    // 当前执行的watcher
    Dep.target = this
    this.getter()
    Dep.target = null;
  }
  update() {
    this.get()
  }
}
```
##### 7.4.6 结果
一个极简的响应式系统搭建完成。在精简代码的同时，保持了源码设计的思想和逻辑。有了这一步的基础。不管是接下来的分析还是理解都要轻松得多了。
