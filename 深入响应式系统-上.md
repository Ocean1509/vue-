initState过程
  初始化props

    props的流程
      - 父组件遇到子组件的占位符节点时，会解析属性，props 的使用是通过属性的形式，如： ，在AST 生成render函数阶段，会解析成 { attrs: {属性： '***'}} 的形式
      - 而在子组件中，props在组件初始化时会进行选项合并，最终配置项里带有props的对象配置
        如： props: { num: { type: null }}
      - 解析出的属性对象会引data的形式传递给组件创建函数 createComponent函数
      - createComponent函数会先对props 进行一次校验和写法规范，之后以组件配置componentOptions的形式， {propsData: '***' } 创建组件Vnode
        ```
        // 创建子组件vnode
          var vnode = new VNode(
            ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
            data, undefined, undefined, undefined, context,
            { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
            asyncFactory
          );
        ```
      - extractPropsFromVNodeData 
         注意点： data.attrs针对编译生成的render函数，data.props针对用户自定义的render函数

         tips: HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命
      - 这个初始化props的过程是在父组件遇到子组件占位符节点时发生的。
    
    接下来子组件进入  initProps的流程

    定义响应式对象

  

  初始化methods  - 简单描述

  初始化data
    组件的data在初始化选项合并时会将data转换成一个函数
    数据对象会挂载到 vm._data 上
    并且会做一层代理，当直接访问 vm.** 时，会代理访问vm._data的值

    将data对象设置观察者属性，Observer 只要设置成拥有观察属性，则对象下的所有属性都会重写getter和setter方法，而getter，setting方法会进行依赖的收集和派发更新
  
    一个实例一个Observer，Observer会对每个属性值的getter和setter进行重写。

    其中会对数组和对象做不同的处理


    Observer -> defineReavtive(设置getter， setter) -> 遇到对象则递归调用Observer
    所以Observer的作用是将data对象中的每个属性都设置成响应式对象

  
  
  初始化initComputed
    computed可以是对象，也可以是函数，但是对象必须有getter方法

    创建内部watcher

  
  初始化 initWatch
    watch 的属性可以是对象，也可以是数组，数组会遍历createWatcher
    createWatcher最终调用 vm.$watch
  


  
  props为什么是单向数据流 ?
      举个例子，父组件维护了一个状态，假设子组件可随意更改父组件甚至祖宗组件的状态，那各组件的状态改变就会变得难以追溯，父组件的状态也可能被子组件意外修改而不可察觉。而单向数据流保证了父组件的状态不会被子组件意外修改如果要修改，只能通过在子组件中dispatch一个action来对全局状态修改，全局状态在通过props分发给子组件；又或是调用父组件的方法；又或是发事件，这些操作是肉眼可见且可控的（用函数式来说，保证了组件就是无副作用的纯函数），不至于造成状态总被意外修改而导致难以维护的情况。




watcher 
  渲染watcher 会在根实例上添加_watcher 属性，

  watcher 和 watchers
同一时刻只能渲染一个watcher


$mount -> 生成渲染wather -> render函数触发 getter方法

```
if (Dep.target) {
  dep.depend();
  if (childOb) {
    childOb.dep.depend();
    if (Array.isArray(value)) {
      dependArray(value);
    }
  }
}
```

第一个Dep.target 为渲染 watcher
dep.depend执行的是watcher 的depend方法

watcher可以理解为被观察者


Dep 是用来存watcher (渲染watcher,和用户watcher)