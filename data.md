>为了深入的介绍响应式系统的内部实现原理，我们花了一整节的篇幅介绍了数据如何初始化成为响应式对象的过程，其中包括```data, computed,props```等数据。上一节的介绍以构建思路为主，对细节化繁为简，并在文章的后半部分在保留源码结构的前提下构建了一个以```data```为数据的响应式系统。有了这些铺垫，这节将深入分析响应式系统的核心。

### 7.5 相关概念
先简单回顾一下几个重要的概念：
- 1. Observer类，实例化一个Observer类会通过```Object.defineProperty```对数据的```getter,setter```方法进行改写，在```getter```阶段进行**依赖的收集**,在数据发生更改阶段，触发```setter```方法进行**依赖的更新**
- 2. watcher类，实例化watcher类相当于创建一个依赖，简单的理解是数据在哪一个地方使用就产生了一个依赖。前面提到的渲染wathcer便是数据在渲染dom时产生的一个依赖。
- 3. Dep类，既然```watcher```理解为每个数据需要监听的依赖，那么对这些依赖的收集和通知则需要另一个类来管理，这个类便是```Dep```,```Dep```需要做的只有两件事，收集依赖和派发更新依赖。
这是响应式系统构建的三个基本核心概念，也是这一节的基础，如果还没有印象，则需要回顾[深入剖析Vue源码 - 响应式系统构建(上)](https://juejin.im/post/5d072a10518825092c7171c4)一文。


### 7.6 问题思考
接下来我会带着以下几个疑问开始分析：
- 1. 实例化```Dep```发生在什么时候。前面已经知道，```Dep```是作为依赖的容器，那么这个容器什么时候产生的呢？
- 2. ```Dep```收集了什么类型的依赖？即```watcher```作为依赖的分类有哪些，分别是什么场景，以及区别在哪里？
- 3. ```Observer```这个类具体对```getter,setter```方法做了哪些事情
- 4. 手写的```watch```和页面数据渲染监听的```watch```如果同时监听到数据的变化，优先级怎么排。
- 5. 有了依赖的收集是不是还有依赖的解除，依赖的解除有哪些逻辑的优化

带着这几个问题，我们以不同数据类型的分类