> 在[深入剖析Vue源码 - 实例挂载,编译流程](https://juejin.im/post/5ccafd4d51882540d472a90e)这一节中，我们将Vue复杂的挂载流程通过图解流程，代码分析的方式简单的梳理了一遍，其中讲到了模板编译的大致流程，在挂载的核心处，我们并没有对编译后函数的渲染过程深入分析。这一节，我们重新回到Vue实例挂载的最后一个流程，如何将编译后的render函数渲染到页面，成为用户所看到真正的DOM节点。

### 4.1 Virtual DOM

#### 4.1.1 浏览器的渲染流程
当浏览器接收到一个Html文件时，JS引擎和浏览器的渲染引擎便开始工作了。从渲染引擎的角度，它首先会将html文件解析成一个DOM树，与此同时，浏览器将识别并加载CSS样式，并和DOM树一起合并为一个渲染树。有了渲染树后，渲染引擎将计算所有元素的位置信息，最后通过绘制，在屏幕上打印最终的内容。JS引擎的作用是通过角度去操作DOM对象，而当我们操作DOM时，很容易触发到渲染引擎的回流或者重绘。
- 回流： 当我们对DOM的修改引发了元素尺寸的变化时，浏览器需要重新计算元素的大小和位置，最后将重新计算的结果绘制出来，这个过程称为回流
- 重绘： 当我们对DOM的修改单纯改变元素的颜色时，浏览器此时并不需要重新计算元素的大小和位置，而只要重新绘制新样式。这个过程称为重绘。很显然回流并重绘更加耗费性能。

#### 4.1.2 操作DOM是缓慢的
有了浏览器渲染机制的知识，我们很容易连想到，当通过JS不断的修改DOM时，不经意间会触发到渲染引擎的回流或者重绘，而这个性能开销是非常巨大的。

就是在数据和真实 DOM 之间建立了一层缓冲

DOM 通常被视为一棵树，元素则是这棵树上的节点（node）

通过 VD 的比较，我们可以将多个操作合并成一个批量的操作，从而减少 dom 重排的次数，进而缩短了生成渲染树和绘制所花的时间
### 4.1
```
Vue.prototype.$mount = function(el, hydrating) {
    ···
    return mountComponent(this, el)
}
function mountComponent() {
    ···
    updateComponent = function () {
        vm._update(vm._render(), hydrating);
    };
}

```