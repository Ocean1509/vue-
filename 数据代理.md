
深入剖析Vue源码 - 数据代理，关联子父组件


> 简单回顾一下这个系列的前两节，前两节花了大篇幅讲了```vue```在初始化时进行的选项合并过程。选项配置是vue实例化的第一步，针对不同类型的选项，```vue```提供了丰富的选项配置策略以保证用户利用复杂的选项配置实现复杂完备的功能应用。
？而在这一节中，我们会分析选项合并后的又两步重要的操作： 数据代理和关联子父组件关系，分别对应的处理过程为initProxy和initLifecycle。这章节的知识点也为后续的响应式系统介绍和模板渲染做铺垫。

### 2.1 数据代理的含义
数据代理的另一个说法是数据劫持，当我们在访问或者修改对象的某个属性时，数据劫持可以拦截这个行为并进行额外的操作或者修改返回的结果。而我们知道```Vue```响应式系统的核心就是数据代理，代理使得数据在访问时进行依赖收集，在修改更新时对依赖进行更新，这是响应式系统的核心思路。而这一切离不开```Vue```对数据做了拦截代理。在分析之前，我们需要掌握两种实现数据代理的方法：
```Object.defineProperty``` 和 ```Proxy```。


##### 2.1.1 Object.defineProperty
> 官方定义：```Object.defineProperty()```方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。

基本用法： 
```Object.defineProperty(obj, prop, descriptor)```

```Object.defineProperty()```可以用来精确添加或修改对象的属性，只需要在```descriptor```对象中将属性特性描述清楚，```descriptor```的属性描述符有两种形式，一种是数据描述符，另一种是存取描述符。我们分别看看各自的特点。

1. 数据描述符，它拥有四个属性配置

- ```configurable```：数据是否可删除，可配置
- ```enumerable```：属性是否可枚举
- ```value```：属性值,默认为```undefined```
- ```writable```：属性是否可读写

2. 存取描述符，它同样拥有四个属性选项

- ```configurable```：数据是否可删除，可配置
- ```enumerable```：属性是否可枚举
- ```get```:一个给属性提供 ```getter``` 的方法，如果没有 ```getter``` 则为 ```undefined```。
- ```set```:一个给属性提供 ```setter``` 的方法，如果没有 ```setter``` 则为 ```undefined```。

**需要注意的是: 数据描述符的value，writable 和 存取描述符中的get, set属性不能同时存在，否则会抛出异常。**
有了```Object.defineProperty```方法，我们可以方便的利用存取描述符中的```getter/setter```来进行数据的监听,这也是响应式构建的雏形(响应式系统的构建放到专门章节分析)。```getter```方法可以让我们在访问数据时做额外的操作处理，```setter```方法使得我们可以在数据更新时修改返回的结果。看看下面的例子,由于设置了数据代理，当我们访问对象```o```的```a```属性时，触发```getter```执行钩子，当修改```a```属性的值时，触发```setter```钩子修改返回结果。
```
var o = {}
var value;
Object.defineProperty(o, 'a', {
    get() {
        console.log('获取值')
        return value
    },
    set(v) {
        console.log('设置值')
        value = qqq
    }
})
o.a = 'sss' 
// 设置值
console.log(o.a)
// 获取值
// 'qqq'

```

前面说到```Object.defineProperty```的```get```和```set```方法是对对象进行监测并响应变化，那么数组类型是否也可以监测呢，如果参照监听属性的思路，我们用数组的下标作为属性，数组的每个元素作为拦截对象，看看数组是否可以使用```Object.defineProperty```进行数据监控拦截。
```
var arr = [1,2,3];
arr.forEach((item, index) => {
    Object.defineProperty(arr, index, {
        get() {
            console.log('数组被getter拦截')
            return item
        },
        set(value) {
            console.log('数组被setter拦截')
            return item = value
        }
    })
})

arr[1] = 4;
console.log(arr)
// 结果
数组被setter拦截
数组被getter拦截
4
```
显然，**已知长度的数组是可以通过索引属性来设置属性的访问器属性的。**但是数组的添加确无法进行拦截，这个也很好理解，不管是通过```arr.push()```还是```arr[10] = 10```添加的数据，数组所添加的索引值并没有预先加入数据拦截中，所以自然无法进行拦截处理。而```Vue```在响应式系统中对数组的拦截的处理是利用方法的重写，这个详细细节可以参考后续的响应式系统分析。

另外如果需要拦截的对象属性嵌套多层，如果没有递归去调用```Object.defineProperty```进行拦截，深层次的数据也依然无法监测的。

##### 2.1.2 Proxy
为了解决像数组这类无法进行数据拦截，以及深层次的嵌套问题，es6引入了```Proxy```的概念，它是真正在语言层面对数据拦截的定义，和```Object.defineProperty```一样，```Proxy```可以修改某些操作的默认行为，但是不同的是，**```Proxy```针对目标对象会创建一个新的实例对象，并将目标对象代理到新的实例对象上，**。 本质的区别创建一个新的对象对原对象做了一层代理，外界对原对象的访问，都必须先通过这层拦截。拦截的结果是我们只要通过操作新的实例对象就能间接的操作真正的目标对象了。针对```Proxy```，下面是基础的写法:
```
var obj = {}
var nobj = new Proxy(obj, {
    get(target, key, receiver) {
        console.log('获取值')
        return Reflect.get(target, key, receiver)
    },
    set(target, key, value, receiver) {
        console.log('设置值')
        return Reflect.set(target, key, value, receiver)
    }
})

nobj.a = '代理'
console.log(obj)
// 结果
设置值
{a: "代理"}
```


```Proxy``` 支持的拦截操作有13种之多，具体可以参照[ES6-Proxy](http://es6.ruanyifeng.com/#docs/proxy)文档,前面提到，```Object.defineProperty```的```getter```和```setter```方法并不适合监听拦截数组的变化，那么新引入的```Proxy```又能否做到呢？我们看下面的例子。

```
var arr = [1, 2, 3]
let obj = new Proxy(arr, {
    get: function (target, key, receiver) {
    // console.log("获取数组元素" + key);
    return Reflect.get(target, key, receiver);
    },
    set: function (target, key, receiver) {
    console.log('设置数组');
    return Reflect.set(target, key, receiver);
    }
})
// 1. 改变已存在索引的数据
obj[2] = 3
// result: 设置数组
// 2. push,unshift添加数据
obj.push(4)
// result: 设置数组 * 2 (索引和length属性都会触发setter)
// // 3. 直接通过索引添加数组
obj[5] = 5
// result: 设置数组 * 2
// // 4. 删除数组元素
obj.splice(1, 1)

```


### 2.2 initProxy
数据拦截的思想不单纯是为了构建响应式系统而准备的，它也可以为**数据进行筛选过滤**，我们接着往下看初始化的代码，在合并选项后，```vue```接下来会为```vm```实例设置一层代理，这层代理可以为**vue在模板渲染时进行一层数据筛选**，这个过程究竟怎么发生的，我们看代码的实现。

```
Vue.prototype._init = function(options) {
    // 选项合并
    ...
    {
        // 对vm实例进行一层代理
        initProxy(vm);
    }
    ...
}
```
```initProxy```的实现如下：
```
// 代理函数
var initProxy = function initProxy (vm) {
    
    if (hasProxy) {
        var options = vm.$options;
        var handlers = options.render && options.render._withStripped
            ? getHandler
            : hasHandler;
        // 代理vm实例到vm属性_renderProxy
        vm._renderProxy = new Proxy(vm, handlers);
    } else {
        vm._renderProxy = vm;
    }
};
```

首先是判断浏览器是否支持原生的```proxy```。
```
var hasProxy =
      typeof Proxy !== 'undefined' && isNative(Proxy);
```
当浏览器支持```Proxy```时，```vm._renderProxy```会代理```vm```实例，并且代理过程也会随着参数的不同呈现不同的效果；当浏览器不支持```Proxy```时，直接将```vm```赋值给```vm._renderProxy```。

读到这里，我相信大家会有很多的疑惑。
**- 1. 这层代理的访问时机是什么，也就是说什么场景会触发这层代理**
**- 2. 参数```options.render._withStripped```代表着什么，```getHandler```和```hasHandler```又有什么不同。**
**- 3. 如何理解为模板数据的访问进行数据筛选过滤。到底有什么数据需要过滤。**
**- 4. 只有在支持原生```proxy```环境下才会建立这层代理，那么在旧的浏览器，非法的数据又将如何展示。**

带着这些疑惑，我们接着往下分析。

##### 2.2.1 触发代理
源码中```vm._renderProxy```出现在```Vue```实例的```_render```方法中，```Vue.prototype._render```是渲染函数转换成```Virtual DOM```的方法，这部分是关于实例的挂载和模板引擎的解析，笔者并不会在这一章节中深入分析，我们只需要先有一个认知，**```Vue```内部在```js```和真实```DOM```节点中设立了一个中间层，这个中间层就是```Virtual DOM```,当我们调用```render```函数时，代理的```vm._renderProxy```对象便会访问到。
```
Vue.prototype._render = function () {
    ···
    // 调用vm._renderProxy
    vnode = render.call(vm._renderProxy, vm.$createElement);
}
```

那么触发拦截的过程又是什么呢？我们回过头看看代理选项```handlers```的是实现。
```handers```函数会根据 ```options.render._withStripped```的不同执行不同的代理函数，**当使用类似```webpack```这样的打包工具时，我们通常使用```vue-loader```插件进行模板的编译，这个时候```options.render```是存在的，并且```_withStripped```的属性也会设置为```true```**(关于编译版本和运行时版本的区别可以参考后面章节)。```getHandler,hasHandler```的逻辑相似，我们只分析上述使用```vue-loader```的场景，```getHandler```的逻辑，读者可以自行分析。

```
var hasHandler = {
    // key in obj或者with作用域时，会触发has的钩子
    has: function has (target, key) {
        ···
    }
};
```
```hasHandler```函数定义了```has```的钩子，前面介绍过,```proxy```的钩子有13个之多，而```has```是其中一个，它用来拦截```propKey in proxy```的操作，返回一个布尔值。除了拦截 ```in``` 操作符外，```has```钩子同样可以用来拦截with语句下的作用对象。例如:
```
var obj = {
    a: 1
}
var nObj = new Proxy(obj, {
    has(target, key) {
        console.log(target) // { a: 1 }
        console.log(key) // a
        return true
    }
})

with(nObj) {
    a = 2
}
```
那么这两个触发条件是否跟```_render```过程有直接的关系呢？答案是肯定的。```vnode = render.call(vm._renderProxy, vm.$createElement);```的主体是```render```函数，而这个```render```函数就是包装成```with```的执行语句,**在调用```with```语句的过程中，该作用域下变量的访问都会触发```has```钩子，这也是模板渲染时之所有会触发代理拦截的原因。**我们通过代码来观察```render```函数的原形。
```
var vm = new Vue({
    el: '#app'     
})
console.log(vm.$options.render)

//输出, 模板渲染使用with语句
ƒ anonymous() {
    with(this){return _c('div',{attrs:{"id":"app"}},[_v(_s(message)+_s(_test))])}
}
```

读到这里，我们恍然大悟，原来```Vue```在模板解析渲染阶段是通过```with```语句开始的，但是同时不免会产生疑惑，从我们以往的认知里[with语句](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with)是不推荐使用的,大致的弊端是由于```with```会形成一个以传入对象为作用域的空间，在查找变量时都是从指定的对象中查找，然而如果查找的变量不是指定对象本身的变量，查找起来会很慢，这就会产生一系列的性能问题。那么作者为什么在渲染阶段使用了```with```呢？这里有一个[官方](https://github.com/vuejs/vue/issues/4115)给出的解释可以参考: 大致的意思是为了减少编译器代码大小和复杂度,并且如果使用了```vue-loader```这类构建工具去构建，官方也提供了不含```with```的版本。


也就是说模板引擎```<div>{{message}}</div>```的渲染显示，会通过Proxy这层代理对数据进行过滤，并对非法数据进行报错提醒。




// 浏览器如果支持es6原生的proxy，则会进行实例的代理，这层代理会在模板渲染时对一些非法或者不存在的字符串进行判断，做数据的过滤筛选。








##### 2.2.2 代理检测过程
接着上面的分析，在模板引擎render渲染时，由于with语句的存在，访问变量时会触发has钩子函数，该函数会进行数据的检测，比如模板上的变量是否是实例中所定义，是否包含_, $这类vue内部保留关键字为开头的变量。同时模板上的变量将允许出现javascript的保留变量对象，例如Math, Number, parseFloat等。
```
var hasHandler = {
    has: function has (target, key) {
        var has = key in target;
        // isAllowed用来判断模板上出现的变量是否合法。
        var isAllowed = allowedGlobals(key) ||
            (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));
            // _和$开头的变量不允许出现在定义的数据中，因为他是vue内部保留属性的开头。
        // warnReservedPrefix警告不能以$ _开头的变量
        // warnNonPresent 警告模板出现的变量在vue实例中未定义
        if (!has && !isAllowed) {
            if (key in target.$data) { warnReservedPrefix(target, key); }
            else { warnNonPresent(target, key); }
        }
        return has || !isAllowed
    }
};

// 模板中允许出现的非vue实例定义的变量
var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
    'require' // for Webpack/Browserify
);
```

### 2.3 initLifecycle
分析完initProxy方法后，接下来是initLifecycle的过程。简单概括，initLifecycle的目的是将当前实例添加到父实例的```$children```属性中，并设置自身的```$parent```属性指向父实例。这为后续子父组件之间的通信提供了桥梁。举一个具体的应用场景：
```
<div id="app">
    <component-a></component-a>
</div>
Vue.component('component-a', {
    template: '<div>a</div>'
})
var vm = new Vue({ el: '#app'})
console.log(vm) // 将实例对象输出
``` 
由于vue实例向上没有父实例，所以```vm.$parent```为undefined，vm的```$children```属性指向子组件componentA 的实例。

![](https://user-gold-cdn.xitu.io/2019/4/3/169e1cbf43f024e6?w=734&h=201&f=png&s=23678)

子组件componentA的 ```$parent```属性指向它的父级vm实例，它的```$children```属性指向为空

![](https://user-gold-cdn.xitu.io/2019/4/3/169e1cd342cb543b?w=780&h=200&f=png&s=22827)


源码解析如下: 
```
function initLifecycle (vm) {
    var options = vm.$options;
    // 子组件注册时，会把父组件的实例挂载到自身选项的parent上
    var parent = options.parent;
    // 如果是子组件，并且该组件不是抽象组件时，将该组件的实例添加到父组件的$parent属性上，如果父组件是抽象组件，则一直往上层寻找，直到该父级组件不是抽象组件，并将，将该组件的实例添加到父组件的$parent属性
    if (parent && !options.abstract) {
        while (parent.$options.abstract && parent.$parent) {
        parent = parent.$parent;
        }
        parent.$children.push(vm);
    }
    // 将自身的$parent属性指向父实例。
    vm.$parent = parent;
    vm.$root = parent ? parent.$root : vm;

    vm.$children = [];
    vm.$refs = {};

    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    // 该实例是否挂载
    vm._isMounted = false;
    // 该实例是否被销毁
    vm._isDestroyed = false;
    // 该实例是否正在被销毁
    vm._isBeingDestroyed = false;
}

```
最后简单讲讲抽象组件，在vue中有很多内置的抽象组件，例如```<keep-alive></keep-alive>,<slot><slot>```等，这些抽象组件并不会出现在子父级的路径上，并且它们也不会参与DOM的渲染。


